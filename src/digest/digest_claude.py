import json
import boto3
from pydantic import BaseModel, ValidationError, Field
from app_settings import BEDROCK_MODEL_ID, BEDROCK_REGION

# --- Configuration ---
MAX_RETRIES = 1  # Number of retries if validation fails

# --- Initialize Bedrock Client ---
client = boto3.client(
    "bedrock-runtime",
    region_name=BEDROCK_REGION
)
print(f"Bedrock client initialized for region: {BEDROCK_REGION}")

# --- Pydantic Models for Validation ---

class NewsletterSource(BaseModel):
    """Represents a single source article within a category."""
    title: str = Field(..., description="The title of the source article.")
    url: str = Field(..., description="The URL of the source article.")
    highlight: str = Field(..., description="A brief 1-2 sentence highlight of what's most notable or interesting about this article.")

class CategoryContent(BaseModel):
    """Represents the content for a single news category."""
    summary: str = Field(..., description="Overall summary of the category's key developments (3-4 sentences).")
    sources: list[NewsletterSource] = Field(..., description="A list of source articles for this category.")

class NewsletterContent(BaseModel):
    """
    Defines the expected structure for the entire newsletter content generated by Claude.
    Used for validating the response.
    """
    opening_paragraph: str = Field(..., description="A concise opening paragraph highlighting 3-5 key stories across categories.")
    # Expects a dictionary where keys are category names (strings) and values match the CategoryContent model.
    categorized_content: dict[str, CategoryContent] = Field(..., description="News content organized alphabetically by category name.")

# --- Helper Function ---

def _prepare_feed_data(feeds):
    """Transforms the input feeds into a JSON-serializable structure for the prompt."""
    feed_data = []
    for feed_title, records in feeds:
        category_data = {
            "category": feed_title,
            "articles": []
        }
        for record in records:
            # Skip potential summary records if they exist
            if "overall_summary" in record:
                continue

            article = {
                "title": record.get("title", "(No Title)"),
                "url": record.get("url", ""),
                "published": record.get("published", "(No Date)"),
                "summary": record.get("summary", "(No Summary)"),
                "notable_aspects": record.get("notable_aspects", ""),
                "domain": record.get("domain", "")
            }
            category_data["articles"].append(article)

        if category_data["articles"]: # Only include categories with articles
             feed_data.append(category_data)
    return feed_data


# --- Core Function ---

def generate_newsletter_digest(feeds):
    """
    Generates a structured newsletter digest using Claude via Bedrock Converse API,
    including validation and retry logic.

    Args:
        feeds: A list of tuples, each containing (feed_title, list_of_records).
               Each record is expected to be a dictionary with article details.

    Returns:
        dict: A dictionary containing the validated newsletter content, matching
              the NewsletterContent Pydantic model structure.

    Raises:
        Exception: If the Bedrock client failed to initialize, no tool use block
                   is found in the response, or if validation fails after retries.
    """
    # 1. Prepare Data for Claude
    feed_data = _prepare_feed_data(feeds)
    if not feed_data:
        print("No valid feed data to process. Returning.")
        return None

    news_content_json = json.dumps(feed_data, indent=2)
    news_info = f"Here is the news content to organize into a newsletter:\n\n{news_content_json}"

    # 2. Define Prompt with Enhancements
    # Concise example added
    example_categorized_content = """
    Example of `categorized_content` structure:
    {
      "Technology": {
        "summary": "Summary of key tech developments...",
        "sources": [
          { "title": "Article A", "url": "http://...", "highlight": "Highlight for A..." }
        ]
      },
      "Finance": {
        "summary": "Summary of financial news...",
        "sources": [
          { "title": "Article B", "url": "http://...", "highlight": "Highlight for B..." },
          { "title": "Article C", "url": "http://...", "highlight": "Highlight for C..." }
        ]
      }
    }
    """

    prompt = f"""
You are creating a daily news digest email newsletter. Your task is to organize the provided news summaries
into a well-structured, informative newsletter. Follow these guidelines:

1. Start with a concise opening paragraph that:
   - Directly summarizes 3-5 key stories from across categories.
   - Mentions specific, eye-catching details or statistics.
   - Avoids greetings like "welcome" or unnecessary pleasantries.
   - Maintains a professional, informative tone.
2. Organize stories alphabetically by the topic/category name in the `categorized_content` JSON object.
3. For each category, provide:
   - An overall summary of key developments (3-4 sentences).
   - A list of sources (`sources`) containing objects with `title`, `url`, and a brief 1-2 sentence `highlight` for each article capturing what's most interesting or notable about it.
4. Use a professional tone focusing on information delivery.
5. Focus on delivering substantive information clearly and concisely.
6. Format the output strictly according to the provided tool schema. Ensure all JSON syntax (curly braces, brackets, commas, quotes) is strictly correct, especially within the nested `categorized_content` object.

DO NOT:
- Include filler content, greetings, or casual phrases.
- Make up additional stories not in the source material.
- Use clickbait language or sensationalism.
- Return `categorized_content` as a JSON *string*; it MUST be a proper JSON object.

{example_categorized_content}

The newsletter should be well-organized, informative, and easy to scan. The article highlights should give readers a clear reason to click on each link.
"""

    # 3. Define Tool Schema (matches Pydantic models)
    tool_list = [
        {
            "toolSpec": {
                "name": "create_newsletter",
                "description": "Create a structured newsletter from the provided news content.",
                "inputSchema": {
                    # The generated schema MUST be nested under the 'json' key
                    "json": NewsletterContent.model_json_schema()
                }
            }
        }
    ]

    # 4. Prepare Initial Messages
    initial_messages = [
        {
            "role": "user",
            "content": [
                {"text": prompt},
                {"text": news_info}
            ]
        }
    ]

    # 5. Implement API Call with Retry Logic
    attempts = 0
    last_exception = None
    raw_result = None # Keep track of the last raw result for debugging

    # Use a copy for message history within retries
    current_messages = initial_messages[:]

    while attempts <= MAX_RETRIES:
        attempts += 1
        print(f"--- Attempt {attempts} to call Bedrock ({BEDROCK_MODEL_ID}) and validate ---")
        try:
            # Make API call to Bedrock
            response = client.converse(
                modelId=BEDROCK_MODEL_ID,
                messages=current_messages,
                inferenceConfig={
                    "maxTokens": 4096,  # Increased slightly for complex structures/retries
                    "temperature": 0.1  # Lowered temp slightly more for structure adherence
                },
                toolConfig={
                    "tools": tool_list,
                    "toolChoice": {"tool": {"name": "create_newsletter"}}
                }
            )

            # Extract the tool use block
            content_blocks = response.get("output", {}).get("message", {}).get("content", [])
            tool_use_block = None
            for block in content_blocks:
                if "toolUse" in block:
                    tool_use_block = block["toolUse"]
                    break

            if not tool_use_block:
                print(f"Error: No 'toolUse' block found in Bedrock response (Attempt {attempts}). Response: {response}")
                # Store the response for potential debugging if needed
                last_exception = Exception(f"No 'toolUse' block found in Bedrock response on attempt {attempts}")
                # Decide if this specific error is retryable or should break
                break # Break loop on missing tool use

            # Extract the raw result from the tool use
            raw_result = tool_use_block.get("input", {})
            if not raw_result:
                 print(f"Warning: 'toolUse' block found but 'input' is empty or missing (Attempt {attempts}).")
                 last_exception = Exception(f"Tool input was empty on attempt {attempts}")
                 # This might be retryable, depending on cause
                 if attempts <= MAX_RETRIES:
                     # Add feedback about the empty input
                     current_messages.append(response["output"]["message"])
                     current_messages.append({
                        "role": "user",
                        "content": [{"text": "The previous response used the tool but provided an empty input. Please generate the complete newsletter content according to the schema."}]
                     })
                     continue
                 else:
                     break


            print(f"Raw result from Claude (Attempt {attempts}):\n{json.dumps(raw_result, indent=2)}")

            # *** Attempt Validation ***
            validated_newsletter = NewsletterContent.model_validate(raw_result)
            print(f"--- Successfully validated Claude's response on attempt {attempts} ---")
            return validated_newsletter.model_dump() # Success!

        except ValidationError as e:
            print(f"--- Pydantic Validation Error on attempt {attempts} ---")
            print(f"Error details: {e}")
            print(f"Raw Result causing validation error:\n{json.dumps(raw_result, indent=2)}") # Log the failing data
            last_exception = e
            if attempts <= MAX_RETRIES:
                print("Preparing retry with validation error feedback...")
                # Add Claude's invalid response and a user message asking for correction
                if "output" in response and "message" in response["output"]:
                     current_messages.append(response["output"]["message"])
                current_messages.append({
                    "role": "user",
                    "content": [{"text": f"The previous response failed JSON validation with this error: {e}. Please carefully review the structure, especially within 'categorized_content', fix the JSON syntax errors (e.g., extra/missing brackets, commas, quotes), and provide a response that strictly matches the required schema."}]
                })
                # Optionally add a small delay before retrying
                # import time
                # time.sleep(2)
            else:
                print("Max retries reached after validation error.")
                break # Exit loop if max retries hit

        except Exception as e: # Catch other errors (e.g., Bedrock API errors, network issues)
            print(f"--- Error during Bedrock call or processing on attempt {attempts} ---")
            print(f"Error details: {e}")
            last_exception = e
            # Depending on the error type, you might decide whether to retry or break immediately.
            # For now, we'll break on general errors.
            break

    # 6. Handle Failure after Retries
    print(f"--- Failed to get a valid newsletter response after {attempts} attempts. ---")
    if raw_result:
        print(f"Last Raw Result before failure:\n{json.dumps(raw_result, indent=2)}")
    else:
        print("No raw result was successfully captured before failure.")

    # Raise a comprehensive error
    error_message = f"Failed to generate valid newsletter digest from Claude after {attempts} attempts."
    if last_exception:
        error_message += f" Last error: {last_exception}"
    raise Exception(error_message)


# --- Example Usage (Optional, for testing) ---
if __name__ == "__main__":
    # Mock feed data for local testing
    mock_feeds = [
        ("Technology", [
            {"title": "Article A", "url": "http://example.com/a", "summary": "Tech news A.", "published": "2024-01-01"},
            {"title": "Article B", "url": "http://example.com/b", "summary": "Tech news B.", "published": "2024-01-02"}
        ]),
        ("Finance", [
            {"title": "Article C", "url": "http://example.com/c", "summary": "Finance news C.", "published": "2024-01-03"}
        ])
    ]

    print("--- Starting Local Test ---")
    try:
        # NOTE: This requires AWS credentials configured for Bedrock access
        # and the necessary model access enabled in the specified region.
        newsletter_data = generate_newsletter_digest(mock_feeds)
        print("\n--- Generated Newsletter Data (Success) ---")
        print(json.dumps(newsletter_data, indent=2))
    except Exception as e:
        print(f"\n--- Local Test Failed ---")
        print(f"Error: {e}")
